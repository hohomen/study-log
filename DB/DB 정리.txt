62. 스키마(schema : a drawing or description of the main parts of something)
-스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specification)를 의미한다.
-스키마는 데이터 사전(=메타 데이터라고도 한다)에 저장된다.

외부 스키마 : 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것.
개념 스키마 :  개체 간의 관계와 제약 조건을 나타내고 데이터베이스의 접근 권한, 보안 정책 및 무결성 규정에 관한 명세를 정의한 것이다.
내부 스키마 : 내부 스키마는 데이터베이스의 물리적 구조를 정의한 것이다.

63. 데이터베이스 설계
데이터베이스 설계)란 데이터베이스의 구조, 즉 데이터베이스 스키마를 개발하는 과정이다.

1. 요구 사항 수집 및 분석 단계)는 데이터베이스 설계의 각 단계 중에서 가장 많은 시간을 할애해야 하는 단계이다. 요구 사항 수집 하고 분석하는 작업에는 다음과 같은 것들이 있다. 
-조직이나 기관에 대한 일반 사항(회사 내규라든지 조직도 등에 대한 자료조사)
-기존 시스템에 대한 기초 조사(양식지나 컴퓨터 화면 상 입출력 정보 분석)
-설문지 작성
-담당자 면담
-업무 현장 방문
이 외에 기능에 대한 분석도 해야 하는데, 전체 시스템을 몇 개의 기능 단위로 나누고, 다시 기능을 세분화한 단위로 나누며, 기능과 기능 사이의 관계를 명확히 정의한다. 전체 시스템 측면에서 기능의 목적과 활동을 재설정한다. 이를 위해서 {데이터 흐름도(DFD, Data Flow Diagram)}(p.97)를 작성하기도 한다.
작성된 {요구 조건 명세}는 주요 사용자 그룹과 함께 다시 검토하고 확인한 후 최종 시스템 명세로 확정한다.


2. 개념적 설계
상향식 방식과 하향식 방식이 있다. 보통 하향식으로 엔티티를 추출해 낸 후에, 상향식으로 하향식에서 아직 분석하지 못한 내용이나 애트리뷰트 등을 보완한다.

하향식 개념적 설계)란 용어에서 의미하는 그대로 포괄적인 상위그룹의 내용을 먼저 정하고 해당 그룹에 속하는 내용을 다시 쪼개서 하위 그룹의 내용을 설계하는 방식이다.
먼저 요구 사항 수집 및 분석 단계로 부터 얻어진 데이터베이스 요구 사항에서 1.엔티티를 추출해내고, 2엔티티들을 식별할 수 있는 키 애트리뷰트를 찾아낸다. 그런 다음 3각 엔티티들 사이의 관계를 정의하는 방식으로 전체적인 데이터베이스를 설계한다.
최종적인 산출물로 {ER 다이어그램}을 작성한다.(개념적 데이터 모델 중에 가장 대표적인 ER 모델은 개체, 속성, 관계 등에 대하여 용이하게 표현할 수 있는 ERD를 정의하고 있다.)


3. 논리적 설계 단계)에서는 두 가지 작업을 수행하게 된다. 
먼저 데이터베이스 관리 시스템을 무엇으로 할 지 선정하는 것이다. 데이터베이스 관리 시스템을 설정할 때는 정책적인 사항을 비롯해서 기술성과 경제성 등을 고려하게 된다.
다음은 정해진 데이터베이스 관리 시스템의 스키마를 만드는 것이다. ER 다이어그램은 인간이 쉽게 이해하기 위해 도입한 수단이다. 따라서 ER 다이어그램을 컴퓨터가 이해할 수 있는 모델링을 해야 한다.(데이터베이스 관리 시스템에 매핑 --> 데이터베이스 관리 시스템의 용어와 개념에 대해서 알아야 한다.) 이런 과정을 논리적 설계라고 한다. 논리적 설계의 산출물로 {관계형 데이터베이스 스키마}를 얻게 된다. 

정규화
이러한 일련의 과정을 따라서 설계한다 하더라도 반드시 좋은 데이터베이스가 되는 것은 아니다. 단순하고 효율적인 관계형 스키마를 도출해 내야만 좋은 데이터베이스를 구축할 수 있다. 효율적인 관리가 필요한 데이터베이스를 구축하려면 논리적 설계에서 도출된 관계형 스키마를 정제할 필요가 있다.

4. 물리적 설계
주어진 응용 프로그램에 대한 성능을 향상시키기 위해서 데이터베이스 파일의 저장 구조와 접근 경로를 결정하는 작업을 수행하게 된다. 물리적 설계 단계에서 수행하는 작업 중 대표적인 예로 인덱스와 역정규화가 있다.

5. 데이터베이스 구현
선정된 데이터베이스 관리 시스템의 DDL로 기술된 명령문을 실행시켜 데이터베이스 스키마와 데이터베이스 파일을 생성한다.

64. ER(Entity Relationship) 모델
개념적 데이터 모델의 가장 대표적인 것. 피터 첸(Peter Chen)에 의해 제안되었다.
ER 모델은 개체, 속성, 관계 등에 대하여 용이하게 표현할 수 있는 ER 도형(Entity Relationship Diagram)을 정의하고 있다.

68. 관계 대수(Relational Algebra)
-관계 대수는 관계 해석과 함께 릴레이션을 다루는 대표적인 이론적 방법이다. 
-관계 대수는 어떻게 질의를 수행할 것인가를 명시하는 절차적인 언어이다. 
-관계 대수는 상용 관계 DBMS들에서 널리 사용되는 SQL의 이론적인 기초이다.
-관계 대수는 SQL을 구현하고 최적화하기 위해 DBMS 내부 언어로서도 사용된다. 

관계 대수는 기존의 릴레이션들로부터 새로운 릴레이션을 생성한다. 릴레이션이나 관계대수식(이것의 결과도 릴레이션임)에 연산자들을 적용하여 보다 복잡한 관계 대수식을 점차적으로 만들 수 있다.
ㄷ 한자

<필수적인 연산자  :  설렉션, 프로젝션, 합집합, 차집합, 카티션 곱 (관계 연산자 중에서 실렉션과 프로젝션을 제외하고 모두 이항 연산자이다.)

1. 실렉션(Selection)  δ(라틴어) : 수평 연산(튜플을 구한다)
실렉션 연산자는 한 릴레이션에서 실렉션 조건(selection condition = predicate)을 만족하는 투플들의 부분 집합을 생성한다.
실렉션 조건(predicate)은 일반적으로 릴레이션의 임의의 애트리뷰트와 상수를 비교연산(=, <>, <=, <, >=, >)할 수 있으며 AND(∧), OR(∨), Not(￢) 등의 논리(부울) 연산자를 사용하여 여러 개의 조건들을 하나의 조건으로 결합시킬 수도 있다.)
질의) EMPLOYEE 릴레이션에서 3번 부서에 소속된 사원들을 검색하라  :  δdno=3(EMPLOYEE) 

2. 프로젝션(Projection) π : 수직 연산
프로젝션 연산자는 실렉션과 달리 한 릴레이션의 애트리뷰트들의 부분집합을 구한다. 프로젝션의 결과로 생성되는 릴레이션은 <애트리뷰트 리스트>에 명시된 애트리뷰트들만 가지며, 이 애트리뷰트들은 애트리뷰트 리스트에 열거된 순서와 동일하게 결과 릴레이션에 나타난다. (cf. 프로젝션 중복 P.153 배움터, 프로젝션 연산의 결과 릴레이션에는 입력 릴레이션으로부터 골라낸 일부 애트리뷰트들만 포함되므로 중복된 투플들이 존재할 수 있다. DBMS의 타협)
형식) π<애트리뷰트 리스트> (릴레이션)

#집합 연산자
-릴레이션은 투플들의 집합이기 때문에 기존의 집합 연산이 릴레이션에도 적용된다.
-집합 연산자들은 두 개의 릴레이션은 입력으로 받아들이므로 이항 연산자이다.
-결과 릴레이션의 차수는 R 또는 S의 차수와 같으며, 결과 릴레이션의 애트리뷰트 이름들은 R의 애트리뷰트들의 이름과 같거나 S의 애트리뷰트들의 이름과 같다.
-집합 연산자의 입력으로 사용되는 두 개의 릴레이션은 [$합집합 호환(union compatible)$]이어야 한다. 실제로 관계 데이터베이스 내의 임의의 두 릴레이션이 합집합 호환인 경우는 드물다. 일반적으로 프로젝션 연산과 같이 어떤 연산의 결과로 유도된 릴레이션들이 합집합 호환인 경우가 많다.
-합집합 호환 : 두 릴레이션 R1(A1, A2, ...An)과 R2(B1, B2, ...Bm)이 합집합 호환일 필요 충분 조건은 n=m이고, 모든 1≤i≤n에 대해 domain(Ai) = domain(Bi)이다. 다시 말해서, 두 릴레이션의 애트리뷰트 수가 같고 대응되는 애트리뷰트들의 도메인이 같다는 것이다.

3. 합집합(Union) ∪
- 릴레이션이 투플들의 집합이므로 결과 릴레이션에서 중복된 투플들은 제외된다.
4. 차집합(Difference) －
5. 카티션 곱 ×
-실제 응용에서는 사용하지 않지만 조인을 하기위한 연산이다.(이론적 배경)
-카티션 곱 R × S는 차수가 n + m이고, 카디날리티가 i * j이고, 애트리뷰트가 (A1, A2, ... An, B1, B2, ... Bn)이며, R과 S의 투플들의 모든 가능한 조합으로 이루어진 릴레이션이다.

<편의를 위해 유도된 연산자.
교집합, (세타, 동등, 자연, 세미 - 조인), 디비전
6. 교집합(Intersection) ∩
7. 조인(Join) ⋈
- Join 연산은 공통 속성을 중심으로 2개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만든다.
- Join 연산의 결과로 만들어진 릴레이션의 차수는 조인된 두 릴레이션의 차수를 합한 것과 같다.(세타 조인, 동등 조인)
- Join 연산의 결과는 카티션 프로덕트 연산을 수행한 다음 Select 연산을 수행한 것과 같다. (조인 연산자는 시간이 오래 걸리는 연산자이므로 조인을 효율적으로 수행하는 여러 가지 알고리즘들이 개발되었다.)(세타 조인을 수행하기 위해서 양쪽 릴레이션의 애트리뷰트들이 세타 조인 조건을 만족하는 투플들만 골라낸다. 이것이 카티션 곱과 조인의 주요 차이점이다.)
- 세타는 (=, <>, <=, <, >=, >) 중의 하나이다. 
- 동등 조인은 세타 조인 중에서 비교 연산자가 =인 조건이다.
- 자연 조인은 동등 조인의 결과 릴레이션에서 조인 애트리뷰트를 한 개 제외한 것을 자연 조인이라고 한다. (자연 조인은 여러 가지 조인 연산자들 중에서 가장 자주 사용된다.)
형식) R⋈(join 조건)S
8. 디비전(Division) ÷ (그림을 보는 것이 이해가 빠를 것이다. 배움터 P.163)
차수가 n+m인 릴레이션 R(A1, A2, ... , An, B1, B2, ... ,Bm)과 차수가 m인 릴레이션 S(B1, B2, ... , Bm)의 디비전 R ÷ S는 차수가 n이고, S에 속하는 모든 투플 u에 대하역 투플 tu(투플 t와 투플 u를 결합한 것)가 R에 존재하는 투플 t들의 집합이다.
사용 예) 3학년을 위해 개설된 전공과목은 5개이다. 학생들 중에서 3학년 전공과목 5개를 모두 수강하고 있는 학생을 검색하라.
형식) R[속성r ÷ 속성s]S : 속성 r과 속성s는 동일 속성 값을 가지는 속성이어야 한다.
(이 형식이라면 S릴레이션 속성s안에 전공과목 5개가 들어있으면 되겠다.)


