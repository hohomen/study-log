JVM(Java Virtual Machine)의 존재와 역할을 아는 것이 자바 개발 환경을 이해하는 데 필수적이다.

자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE(운영체제)에 의해 가상의 컴퓨터인 JVM 상에서 구동된다.
(다만 배포되는 편의를 위해 JDK가 JRE를 포함하고 다시 JRE는 JVM을 포함하는 형태로 배포된다.)
JDK는 자바 소스 컴파일러인 javac.exe를 포함하고 있고
JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다.
Write Once Run Anywhere

(모든)프로그램이 메모리를 사용하는 방식
  코드 실행 영역  |  데이터 저장 영역

객체 지향 프로그램에서는 데이터 저장 영역을 다시 세 개의 영역으로 분할해서 사용하다.
  코드 실행 영역  |  스태틱 영역, 스택 영역 , 힙 영역

(메모리의 코드 실행 영역을 공부하면 컴퓨터의 작동 원리를 이해하는 데 큰 도움이 된다. 욕심 있다면 어셈블리어)


객체 지향을 이해하기 위해 먼저 객체 지향 속 절차/구조적 프로그래밍을 이해해 보자.(절차/구조적 프로그래밍은 따로 정하였음)

1. JRE는 먼저 프로그램 안에 main( ) 메서드의 존재가 확인되면 JVM에 전원을 넣어 부팅한다.
2. JVM이 맨 먼저 하는 일은 전처리라고 하는 과정이다. 먼저 java.lang 패키지를 T메모리의 스태틱 영억에 가져다 놓는다.
3. JVM은 개발자가 작성한 모든 클래스*와 임포트 패키지* 역시 스태틱 영역에 가져다 놓는다.
4. main( ) 메서드가 놀기 위해 스택 프레임이 스택 영역에 할당된다.
(조금 더 정확히는 여는 중괄호를 만날 때마다 스택 프로엠이 하나식 생긴다. 클래스를 정의하는 중괄호 빼고.)
5. 메서드의 인자 args를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보한다.
6. main( ) 메서드가 끝나면 JRE는 JVM을 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다.
힙 영역은 OOP에서 클래스와 객체를 이야기한 이후에 아주 중요한 영역이지만 절차적 프로그램을 학습하는 동안은 생략한다.


변수와 메모리.

#블록 스택 프레임
스택 프레임(Stack Frame)은 여는 중괄호를 만날 때마다 스택 프레임이 하나식 생긴다.(클래스 정의를 시작하는 여는 중괄호만 빼고 말이다.)

public static void main(String[] args) { //스택 프레임
        int i = 10;
        int k = 20;        
        if(i == 10){ // 스택 프레임(Eclipse는 제어문의 스택 프레임까지는 보여주지 않는다.)
            int m = k + 5;
              k = m;
        }// 스택 프레임 소멸
        else {
            int p = k + 10;
              k = p;
        }        
        k = m + p;  // 이것의 결과를 예측해보자.
}// 스택 프레임 소멸


#(p.90)Heap 영역(추상화와 T 메모리)
class Mouse{ //public class는 같은 이름의 .java 파일로 저장되어야 한다.
    public String name;
    public int age;
    public int countOfTail;
    
    public void sing(){
        System.out.println(name + "찍찍!!");
    }
}

public class MouseDriver{
    public static void main(String[] args) {

    /*클래스 멤버와 객체 멤버를 구분하는 자바 키워드는 static이다. 
    UML 표기법에서 클래스 멤버는 밑줄을, 객체 멤버는 밑줄 없이 표현한다. 
    main 메서드는 밑줄이 sing 메서드는 밑줄이 없는 표기를 한다. 
    */
        Mouse mickey = new Mouse(); //3개의 명령어로 구성된다.(실행 순서는 번호순)

        1. Mouse mickey에 의해 Mouse 타입의 객체를 참조할 수 있는 객체 참조 변수 mickey가
        T메모리의 스택 영역 중에서도 main( ) 메서드 스택 프레임 안에 생성된다. 
        2. new Mouse( ) 객체 생성자를 호출하는 구문이다. 생성된 객체는 T메모리의 힙 영역에 배치된다.
        //모든 메모리는 각자의 주소를 가지고 있는데 여기서 힙 영역에 저장된 Mouse 클래스의 인스턴스의 시작주소가 100번지라고 가정한다면
        3. =(대입문) 에 의해서 mickey 객체 참조 변수에 할당 되는 값은 시작 주소 100이 된다.

        mickey.name = "미키"; // String은 객체이기에 별도의 공간에... 이뮤터블.. 우선 pass
        mickey.age = 85; //값을 할당한다.
        mickey.countOfTail = 1;
        mickey.sing();
        T메모리 상의 변화는 없다. 객체 참조 변수 mickey가 참조하는 Mouse 객체의 sing( ) 메서드가 코드 실행 영역에서 실행되어 화면에 "찍찍!"을 출력할 것이다.
        
        mickey = null; //객체 참조 변수 mickey가 더 이상 힙 영역에 존재하는 Mouse 객체를 참조하지 않는다. 가비지 컬렉터가 다녀갔다면 T메모리에서 사라진다.
        
        //이전과 같은 과정
        Mouse jerry = new Mouse();
        jerry.name = "제리";
        jerry.age = 73;
        jerry.countOfTail = 1;
        
        jerry.sing();
    }  
}

#(p101)클래스 영역 (클래스 멤버 = static 멤버 = 정적 멤버 & 객체 멤버  = 인스턴스 멤버 = 오브젝트 멤버 & 필드 = 속성 = 프로퍼티)

그런데 쥐는 클래스인데 꼬리 개수에 답이 있다.
        mickey.countOfTail = 1;
        jerry.countOfTail = 1;
T메모리를 보면 모든 Mouse 객체가 모두 같은 값을 갖는 꼬리 개수 속성이 있음에도 Mouse 객체 수 만큼 아까운 메모리를 잡아먹고 있다.
같은 유형(클래스)의 모든 객체가 같은 값을 가지고 있다면 그 값을 static 키워드를 붙여 클래스에 저장한다.

정적 멤버(클래스 멤버) 속성으로 적당한 속성은 다음과 같은 것들이 있다.
사람 클래스의 인구
고양이 클래스의 다리 개수, 승용차 클래스의 바퀴 개수
보병 클래스의 주특기 번호
남자 클래스의 주민등록번호 성별코드
박카스 클래스의 제조사명, 용량, 성분
(물론 이외의 경우에도 쓸 수 있겠지만 그때는 정당한 논리를 가지고 써야 한다.)


변수와 초기화
클래스 속성과 객체 속성은 별도의 초기화를 해주지 않아도 정수형은 0, 부동소수점형은 0.0, 논리형은 false, 객체는 null로 초기화된다.
지역 변수는 한 지역에서만 쓰는 변수이지만 멤버 변수는 공유 변수의 성격을 가지고 있기 때문이다.



#상속과 T메모리
public class Animal {
	public String name;

	public void showName() {
		System.out.printf("안녕 나는 %s야. 반가워\n", name);
	}
}

public class Penguin extends Animal {
	public String habitat;

	public void showHabitat() {
		System.out.printf("%s는 %s에 살아\n", name, habitat);
	}
}

	public static void main(String[] args) {
		Penguin pororo = new Penguin();

		pororo.name = "뽀로로";
		pororo.habitat = "남극";

		pororo.showName();d
		pororo.showHabitat();
1.// Penguin 클래스의 인스턴스만 힙 영역에 생긴 게 아니라 Animal 클래스의 인스턴스도 함께 힙 영역에 생긴 것을 볼 수 있다.
(모든 클래스의 최상의 클래스인 Object 클래스의 인스턴스도 함께 생성된다.)
그리고 객체 참조 변수는 Penguin 인스턴스를 가리키고 있다.

		Animal pingu = new Penguin();
2.//역시 Penguin 클래스의 인스턴스만 힙 영역에 생긴 게 아니라 Animal 클래스의 인스턴스도 함께 힙 영역에 생긴 것을 볼 수 있다.
그런데 pingu 객체 참조 변수가 가리키고 있는 것은 Penguin 인스턴스가 아닌 Animal 인스턴스다. 
		pingu.name = "핑구";
		// pingu.habitat = "EBS";
따라서 pungu 객체 참조 변수는 펭귄의 서식지(habitat) 속성과 서식지를 알려주는 showHabitat 메서드를 사용할 수 없다.
		pingu.showName();
		// pingu.showHabitat();

		// Penguin happyfeet = new Animal(); 불가능한 명령
	}
#다형성과 T메모리 p.131
3.상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출 된다.
 (+인터페이스 역시 오버라이딩을 하므로 다형성이라 볼 수 있을 것이다.)


캡슐화 : 정보 은닉
private : 같은 클래스 내에서만 접근이 가능하다.
default : 같은 패키지 내에서만 접근이 가능하다.
protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
(패키지에 관계없이 상속관계에 있는 자손클래스에서 접근할 수 있도록 하는 것이 제한 목적)
public : 접근 제한이 전혀 없다.










