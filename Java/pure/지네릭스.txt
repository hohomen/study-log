문법적 특성
- 기본 자료형을 타입 매개변수에 대입할 수 없다.
- 타입 매개변수를 static 필드의 타입으로 사용할 수 없다.
- 제네릭 타입의 배열을 선언할 수 없다. (컴파일 시점에 자료형을 알아야 하므로)

#자바의 정석
지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능이다. -> 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.(기존 Object로 선언한 뒤에 형변환)
클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미한다.(메서드의 매게변수와 비슷하게 동작)

장점
1. 타입 안정성을 제공한다.
2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.

기존 선언.
class Box {
	Object item;

	void setItem(Object item) { this.item = item;}
	Object getTiem() { return item; }
}
지네릭스를 이용한 선언.
class Box<T>{  //T를 타입 변수(type variable)라고 하며 T가 아닌 다른 것을 사용해도 된다.
	T item;
	void setItem(T item) { this.item = item;}
	T getTiem() { return item; }
}
* Map<K, V> 와 같이 ','콤마를 구분자로 타입 변수를 여러 개 선언할 수 있다.
* class Box<String> 만일 Box 클래스에 String만 담을 거라면, 타입 변수를 선언하지 않고 위와 같이 직접 타입을 적어주는 것도 가능하다.

추정이 가능한 경우 타입을 생략할 수 있다.(JDK1.7~)
Box<Apple> appleBox = new Box<>( );

실재 활용 사례 : List의 타입 안정성을 증가시킨다.
    @Override
    public List<BoardVO> listSearchCriteria(Criteria cri) throws Exception {
        return dao.listSearch(cri);
    }


#생활코딩
#What
포괄적인, 일반적인
클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미한다.(메서드의 매게변수와 비슷하게 동작)

class Person<T>{
    public T info;
}
 
public class GenericDemo { 
    public static void main(String[] args) {
        Person<String> p1 = new Person<String>();
        Person<StringBuilder> p2 = new Person<StringBuilder>();
    } 
}

#Why
지네릭스는 자바의 기능 중에서 늦게 도입된 기능이다. 꾀나 숙고한 뒤에 도입된 기능이라 볼 수 있는데 지네릭스 도입 이전에 사람들이 겪었던 어려움을 확인하면서 지네릭스의 유용성을 알아보자.(프로그래밍에 대한 시야를 키워보자)

package org.opentutorials.javatutorials.generic;
class StudentInfo{
    public int grade;
    StudentInfo(int grade){ this.grade = grade; }
}
class StudentPerson{  /////// 두 클래스는 로직이 같다.
    public StudentInfo info;
    StudentPerson(StudentInfo info){ this.info = info; }
}
class EmployeeInfo{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
}
class EmployeePerson{ /////// 두 클래스는 로직이 같다.
    public EmployeeInfo info;
    EmployeePerson(EmployeeInfo info){ this.info = info; }
}
public class GenericDemo {
    public static void main(String[] args) {
        StudentInfo si = new StudentInfo(2);
        StudentPerson sp = new StudentPerson(si);
        System.out.println(sp.info.grade); // 2
        EmployeeInfo ei = new EmployeeInfo(1);
        EmployeePerson ep = new EmployeePerson(ei);
        System.out.println(ep.info.rank); // 1
    }
}
StudentPerson, EmployeePerson 클래스는 로직이 중복된다. 
중복을 제거하기 위해 모든 클래스의 부모 클래스인 Object를 사용하였다.

package org.opentutorials.javatutorials.generic;
class StudentInfo{
    public int grade;
    StudentInfo(int grade){ this.grade = grade; }
}
class EmployeeInfo{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
}
class Person{////////
    public Object info;
    Person(Object info){ this.info = info; }
}
public class GenericDemo {
    public static void main(String[] args) {
        Person p1 = new Person("부장"); <----- 누군가 Person 클래스의 취지를 잊고 String 문자열을 코딩한다.
        EmployeeInfo ei = (EmployeeInfo)p1.info; ///문자열을 EmployeeInfo타입으로 형변환한다.
        System.out.println(ei.rank);
    }
}

이런 문제는 문법적으로는 아무런 문제가 없다. 하지만 코드의 목적, 취지와는 부합되지 않는다. 이 버그는 컴파일 타임에 검출되지 않기 때문에 아주 심각한 문제를 초래할 수 있다. 
런타임 도중 이러한 오류가 발생한다.
Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to org.opentutorials.javatutorials.generic.EmployeeInfo at org.opentutorials.javatutorials.generic.GenericDemo.main(GenericDemo.java:17)

이것을 지네릭스로 바꿔보자.
package org.opentutorials.javatutorials.generic;
class StudentInfo{
    public int grade;
    StudentInfo(int grade){ this.grade = grade; }
}
class EmployeeInfo{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
}
class Person<T>{
    public T info;
    Person(T info){ this.info = info; }
}
public class GenericDemo {
    public static void main(String[] args) {
        Person<EmployeeInfo> p1 = new Person<EmployeeInfo>(new EmployeeInfo(1));
        EmployeeInfo ei1 = p1.info;
        System.out.println(ei1.rank); // 성공
         
        Person<String> p2 = new Person<String>("부장");
        String ei2 = p2.info;
        System.out.println(ei2.rank); // 컴파일 실패
    }
}
type safe가 좋지 않다. 컴파일 언어의 장점.
코드의 중복을 제거하는 것을 통해서 더 좋은 코드를 만들었다고 생각했는데 타입 안정성을 보장받을 수 없어졌다.
결론: 지네릭스는 코드 중복의 제거와 타입 안전성을 보장 2가지 목적을 위해서 도입된 기능이다.


#지네릭스의 특성
package org.opentutorials.javatutorials.generic;
class EmployeeInfo{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
}

//느낀점 : 마치 클래스 옆에 매개변수를 선언하듯 지네릭스를 쓰는구나.(기존에 없던 문법요소다.)
class Person<T, S>{ // 타입 안정성 체크를 여러 개도 할 수 있다.
    public T info;
    public S id;
    Person(T info, S id){ 
        this.info = info; 
        this.id = id;
    }
    public <U> void printInfo(U info){  <-- 아직 타입을 확정하고 싶지 않다.{(접근 제어자와 리턴값 사이에 선언}
        System.out.println(info);
    //지네릭스는 클래스 레벨에서만 쓸 수 있는 것은 아니고 메소드 레벨에서도 사용할 수 있다.
cf. 오버로딩은 함수명 하나를 가지고 인자 목록만 달리하면 되니 얼마나 사용하기 편리한지 알 수 있다. 특히 자바 5에서 추가된 제네릭을 이용하면 하나의 함수만 구현해도 다수의 함수를 구현한 효과를 낼 수 있다. 다형성에 대해 사용 편의성이라고 정의한 이유는 바로 이 때문이다.
    }
}
XX
    public static void main(String[] args) {
        Person<EmployeeInfo, int> p1 = new Person<EmployeeInfo, int>(new EmployeeInfo(1), 1);
    // 지네릭스에는 참조형 변수만 올 수 있다.
XX    
OO
public class GenericDemo {
    public static void main(String[] args) {
        EmployeeInfo e = new EmployeeInfo(1);
        Integer i = new Integer(10);
        Person<EmployeeInfo, Integer> p1 = new Person<EmployeeInfo, Integer>(e, i);
        (=Person p1 = new Person(e, i); //추정 가능한 타입은 생략 가능하다.)
        //기본 데이터 타입을 마치 객체인 것 처럼 만들 수 있는 클래스를 사용한다.(Integer, wrapper class)
        System.out.println(p1.id.intValue());
    }
}
OO

#지네릭스 타입 제한
(지네릭스는 타입 체크가 다소 느슨한 감도 있다. 자바 스타일이 아니다.)
abstract class Info{
    public abstract int getLevel();
}
class EmployeeInfo extends Info{
    public int rank;
    EmployeeInfo(int rank){ this.rank = rank; }
    public int getLevel(){
        return this.rank;
    }
}
class Person<T extends Info>{
// 여기서 extends는 부모 클래스를 의미한다. 즉 인터페이스이어도 extends 키워드를 사용한다.
// super 키워드로 부모 타입을 제한할 수 있지만 잘 사용하지 않아 여기서는 정리하지 않는다.
    public T info;
    Person(T info){ this.info = info; }
}
public class GenericDemo {
    public static void main(String[] args) {
        Person p1 = new Person(new EmployeeInfo(1));
        Person<String> p2 = new Person<String>("부장"); //에러
    }
}
