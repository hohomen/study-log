#문법적 특성
인터페이스 
오직 추상메서드와 상수만을 멤버로 가질 수 있다.
모든 멤버변수는 public static final 이어야 한다.
모든 메서드는 public abstract 이어야 한다. (이를 생략할 수 있다.)
(원래는 인터페이스의 모든 메서드는 추상메서드이어야 하는데, JDK1.8부터 인터페이스에 static 메서드와 디폴트 메서드(=조상 메서드 ex. default void newMethod() { content } )의 추가를 허용하는 방향으로 변경되었다.
이러면 다중상속과 비슷한 문제로 인해 디폴트 메서드의 충돌문제가 있는데 해결방법은 다음과 같다.
1. 여러 인터페이스의 디폴트 메서드 간의 충돌
--> 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
--> 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.

추상클래스 
추상클래스는 미완성 설계도에 비유할 수 있다.
미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다.
추상 클래스의 선언 : absract class 클래스이름{ ... } 
추상 메서드의 선언 : abstract 리턴타입 메서드이름( );


차이점.
인터페이스는 일종의 추상클래스이지만 추상화의 정도가 더 높다.
선언부는 있는데 구현부가 없는 메서드를 갖고 있다는 공통점이 있다.
하지만 추상 클래스는 구현부가 있는 메서드를 가질 수 있다는 점에서 인터페이스와 차이가 있다.
또한 추상 클래스와 인터페이스는 탄생한 배경이 다르다.
추상 클래스는 정의할 수 없는 상위클래스의 메소드 때문이라면
인터페이스는 다중 상속과 관련이 있다.



상위 클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다.

상위 클래스가 풍성할수록 좋은 이유는 LSP(리스코프 치환 원칙)에 따른 이유라고 할 수 있다.
인터페이스에 메서드가 적을수록 좋은 이유는 ISP(인터페이스 분할 원칙)에 따른 이유라고 할 수 있다.
(객체 지향 설계 5원칙)

추상 메서드(Abstract Method) : 선언부는 있는데 구현부가 없는 메서드를 말한다.
추상 클래스 : 추상 메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스(Abstract Class)로 선언해야 한다.
	      추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다. 오버라이딩 강제.
	      추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. 즉, new를 사용할 수 없다.

클래스 = 분류

인터 페이스
다중 상속은 득실 관계에서 실이 더 많았기에 자바와 C#은 과감히 다중 상속을 포기했다. 대신에 자바에서는 인터페이스를 도입해 다중 상속의 득은 취하고 실은 과감히 버렸다. 

왜 다중 상속을 지원하지 않는가? 다중 상속의 다이아몬드
사람도 수영할 수 있고 물고기도 수영할 수 있는데 인어공주에게 수영하라면 어떻게 할 것인가?

그러면 상속(is a kind of)와 달리 인터페이스는 어떤 관계를 나타내는 것일까?
긴 세월을 거쳐서 정제되고 발달하다 보니 인터페이스는 상속과는 다르게 쓰는 것이 유용하다는 결론에 도달 한다. 인터페이스는 be able to, "무엇을 할 수 있는"이라는 표현 형태로 만드는 것이 좋다.
자바 API에서도 이러한 be able to 형식의 인터페이스를 많이 볼 수 있다.
Serializable, Cloneable, Comparable, Runnable

인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제하게 된다.

인터페이스의 특징
public 추상 메서드와 public 정적 상수만 가질 수 있다.

public interface BoardDAO {
	double PI = 3.14159;
	void create(BoardVO vo)throws Exception;
}
이 코드는 아래와 같은 코드이다.
public interface BoardDAO {
	public static final double PI = 3.14159;
	public abstract void create(BoardVO vo)throws Exception;
}

어떤 코드가 좋은 코드일까? 정답은 없지만 인터페이스를 모르는 사람에게도 후자는 코드를 명확히 할 수 있다.

