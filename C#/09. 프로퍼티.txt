객체지향 언어라면 모름지기 "은닉성"을 표현할 수 있어야 합니다. private나 protected 접근 한정자를 이용합니다. C# 프로그래머도 이 방법을 그대로 사용할 수 있지만, C# 언어는 이보다 더 우아한 장치를 제공합니다.

은닉성과 편의성은 함께 할 수 없는 물과 기름같은 존재일까요? 꼭 그렇지는 않습니다. 프로퍼티를 이용하면 은닉성과 편의성, 이 두 마리의 토끼를 다 잡을 수 있습니다.

# 프로퍼티(C# 1.0)

class 클래스이름
{
    데이터형식 필드이름;
    접근한정자 데이터형식 프로퍼티이름
    {
        get
        {
            retunr 필드이름;
        }
        
        set
        {
            필드이름 = value;
        }    
    }
}

예제)
using System;

namespace Property
{
    class BirthdayInfo
    {
        private string name;
        private DateTime birthday;

        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                name = value;
            }
        }

        public DateTime Birthday
        {
            get
            {
                return birthday;
            }
            set
            {
                birthday = value;
            }
        }

        public int Age
        {
            get
            {
                return new DateTime(DateTime.Now.Subtract(birthday).Ticks).Year;
            }
        }
        
    }

    class MainApp
    {
        static void Main(string[] args)
        {
        
        // 이제 BirthdayInfo의 객체는 '=' 할당 연산자를 통해 Name, birth 필드에 데이터를 저장하고 또 반대로 데이터를 읽어올 수 있습니다.
        
            BirthdayInfo birth = new BirthdayInfo();
            birth.Name = "서현";
            birth.Birthday = new DateTime(1991, 6, 28);

            Console.WriteLine("Name : {0}", birth.Name);
            Console.WriteLine("Birthday : {0}", birth.Birthday.ToShortDateString());
            Console.WriteLine("Age : {0}", birth.Age);
        }
    }
}


# 자동 구현 프로퍼티(C#3.0, 많은 경우에 중복된 코드를 작성 -> 코드를 더 단순하게)

public class NameCard
{
    public string Name
    {
        get; set;
    }
    public string PhoneNumber
    {
        get; set;
    }
}


# C#7.0 자동 구현 프로퍼티 선언과 동시에 초기화 수행 가능

public class NameCard
{
    public string Name{ get; set; } = "Unknown";
    public string PhoneNumber{ get; set; } = "000-0000";
}




# 인터페이스와 프로퍼티
인터페이스는 메소드뿐만 아니라 프로퍼티와 인덱서도 가질 수 있습니다.
여기서 한 가지 문제가 있는데, 인터페이스의 프로퍼티 선언이 클래스의 자동 구현 프로퍼티 선언과 그 모습이 동일하다는 사실입니다. --> 파생 클래스는 부모 인터페이스에 선언된 모든 프로퍼티를 구현해야 합니다(반드시 프로퍼티를 구현해야 합니다. 이 때, 자동 구현 프로퍼티를 이용하는 것도 가능합니다.)


# 추상 클래스와 프로퍼티

추상 프러퍼티는 다음과 같이 abstract 한정자를 이용해서 선언합니다.
abstract class 추상 클래스 이름
{
    abstract 데이터형식 프로퍼티이름
    {
        get;
        set;
    }
}


